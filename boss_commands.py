from datetime import datetime, timedelta
import pytz
import discord
from discord.ext import commands, tasks
from discord.ui import Button, View, Select, Modal
from discord import TextStyle, app_commands
from collections import defaultdict
import random
import traceback
import re
import json
import os
import asyncio
from typing import Optional
from database import (
    save_timer, save_user_stats, clear_timer,
    add_user_notification, remove_user_notification, get_user_notifications,
    create_backup, restore_backup, connect_db, load_db_data
)
from shared_functions import get_boss_by_abbreviation, format_time_remaining, parse_time_input, validate_time, get_next_bosses
from views import BossControlView

# Configura√ß√£o do fuso hor√°rio do Brasil
brazil_tz = pytz.timezone('America/Sao_Paulo')

async def send_notification_dm(bot, user_id, boss_name, sala, respawn_time, closed_time):
    try:
        user = await bot.fetch_user(int(user_id))
        if user:
            await asyncio.sleep(1)  # Delay para evitar rate limit
            await user.send(
                f"üîî **Notifica√ß√£o de Boss** üîî\n"
                f"O boss **{boss_name} (Sala {sala})** que voc√™ marcou est√° dispon√≠vel AGORA!\n"
                f"‚úÖ Aberto at√©: {closed_time.strftime('%d/%m %H:%M')} BRT\n"
                f"Corra para pegar seu loot! üèÜ"
            )
            return True
    except discord.Forbidden:
        print(f"Usu√°rio {user_id} bloqueou DMs ou n√£o aceita mensagens")
    except discord.HTTPException as e:
        if e.status == 429:
            retry_after = e.retry_after
            print(f"Rate limit atingido. Tentando novamente em {retry_after} segundos")
            await asyncio.sleep(retry_after)
            return await send_notification_dm(bot, user_id, boss_name, sala, respawn_time, closed_time)
        else:
            print(f"Erro ao enviar DM para {user_id}: {e}")
    except Exception as e:
        print(f"Erro ao enviar DM para {user_id}: {e}")
    
    return False

async def create_history_embed(bot, boss_timers):
    """Cria embed com hist√≥rico de anota√ß√µes (vers√£o corrigida)"""
    conn = None
    try:
        print("Iniciando busca por hist√≥rico...")
        conn = await connect_db()
        if conn is None:
            print("Erro: N√£o foi poss√≠vel conectar ao banco de dados")
            return discord.Embed(
                title="Erro de Conex√£o",
                description="N√£o foi poss√≠vel conectar ao banco de dados",
                color=discord.Color.red()
            )
        
        async with conn.cursor() as cursor:
            await cursor.execute("""
            SELECT boss_name, sala, death_time, respawn_time, recorded_by 
            FROM boss_timers 
            WHERE death_time IS NOT NULL
            ORDER BY death_time DESC 
            LIMIT 10
            """)
            
            history = await cursor.fetchall()
            print(f"Hist√≥rico encontrado: {len(history)} registros")
            
            if not history:
                return discord.Embed(
                    title="üìú Hist√≥rico de Anota√ß√µes",
                    description="Nenhuma anota√ß√£o registrada ainda.",
                    color=discord.Color.blue()
                )
            
            embed = discord.Embed(
                title="üìú Hist√≥rico das √öltimas Anota√ß√µes",
                color=discord.Color.gold()
            )
            
            for idx, record in enumerate(history, 1):
                death_time = record[2].astimezone(brazil_tz) if record[2] else None
                respawn_time = record[3].astimezone(brazil_tz) if record[3] else None
                
                embed.add_field(
                    name=f"{idx}. {record[0]} (Sala {record[1]})",
                    value=(
                        f"‚è± Morte: {death_time.strftime('%d/%m %H:%M') if death_time else 'N/A'}\n"
                        f"üîÑ Abriu: {respawn_time.strftime('%d/%m %H:%M') if respawn_time else 'N/A'}\n"
                        f"üë§ Por: {record[4] or 'Desconhecido'}"
                    ),
                    inline=False
                )
            
            return embed
            
    except Exception as e:
        print(f"Erro detalhado ao buscar hist√≥rico: {str(e)}")
        traceback.print_exc()
        return discord.Embed(
            title="Erro",
            description=f"Ocorreu um erro ao buscar o hist√≥rico: {str(e)}",
            color=discord.Color.red()
        )
    finally:
        if conn:
            await conn.ensure_closed()

async def create_unrecorded_embed(bot, boss_timers):
    """Cria embed com bosses que fecharam sem registro (vers√£o corrigida)"""
    conn = None
    try:
        print("Iniciando busca por bosses n√£o anotados...")
        conn = await connect_db()
        if conn is None:
            print("Erro: N√£o foi poss√≠vel conectar ao banco de dados")
            return discord.Embed(
                title="Erro de Conex√£o",
                description="N√£o foi poss√≠vel conectar ao banco de dados",
                color=discord.Color.red()
            )
        
        async with conn.cursor() as cursor:
            await cursor.execute("""
            SELECT 
                boss_name, 
                sala, 
                death_time, 
                respawn_time, 
                closed_time,
                recorded_by
            FROM 
                boss_timers
            WHERE 
                closed_time IS NOT NULL AND
                closed_time < NOW() AND
                death_time IS NOT NULL
            ORDER BY 
                closed_time DESC 
            LIMIT 10
            """)
            
            unrecorded = await cursor.fetchall()
            print(f"Bosses n√£o anotados encontrados: {len(unrecorded)} registros")
            
            if not unrecorded:
                return discord.Embed(
                    title="üî¥ Bosses Fechados Recentemente",
                    description="Nenhum boss foi fechado recentemente sem registro.",
                    color=discord.Color.blue()
                )
            
            embed = discord.Embed(
                title="üî¥ √öltimos Bosses Fechados",
                description="Estes bosses foram fechados recentemente:",
                color=discord.Color.red()
            )
            
            for idx, record in enumerate(unrecorded, 1):
                death_time = record[2].astimezone(brazil_tz) if record[2] else None
                respawn_time = record[3].astimezone(brazil_tz) if record[3] else None
                closed_time = record[4].astimezone(brazil_tz) if record[4] else None
                
                embed.add_field(
                    name=f"{idx}. {record[0]} (Sala {record[1]})",
                    value=(
                        f"‚è± Morte registrada: {death_time.strftime('%d/%m %H:%M') if death_time else 'N/A'}\n"
                        f"üîÑ Per√≠odo aberto: {respawn_time.strftime('%d/%m %H:%M') if respawn_time else 'N/A'} "
                        f"at√© {closed_time.strftime('%d/%m %H:%M') if closed_time else 'N/A'}\n"
                        f"üë§ Registrado por: {record[5] or 'Ningu√©m'}"
                    ),
                    inline=False
                )
            
            return embed
            
    except Exception as e:
        print(f"Erro detalhado ao buscar bosses fechados: {str(e)}")
        traceback.print_exc()
        return discord.Embed(
            title="Erro",
            description=f"Ocorreu um erro ao buscar os bosses fechados: {str(e)}",
            color=discord.Color.red()
        )
    finally:
        if conn:
            await conn.ensure_closed()

async def setup_boss_commands(bot, boss_timers, user_stats, user_notifications, table_message, NOTIFICATION_CHANNEL_ID):
    async def create_ranking_embed():
        """Cria embed com o ranking de usu√°rios que mais registraram bosses"""
        sorted_users = sorted(user_stats.items(), key=lambda x: x[1]['count'], reverse=True)
        
        embed = discord.Embed(
            title="üèÜ RANKING DE ANOTA√á√ïES",
            color=discord.Color.gold()
        )
        
        if not sorted_users:
            embed.description = "Nenhuma anota√ß√£o registrada ainda."
            return embed
        
        ranking_text = []
        for idx, (user_id, stats) in enumerate(sorted_users[:10]):
            try:
                user = await bot.fetch_user(int(user_id))
                username = user.name
            except:
                username = stats.get('username', f"Usu√°rio {user_id}")
            
            medal = ""
            if idx == 0:
                medal = "ü•á "
            elif idx == 1:
                medal = "ü•à "
            elif idx == 2:
                medal = "ü•â "
            
            last_recorded = stats['last_recorded'].strftime("%d/%m %H:%M") if stats['last_recorded'] else "Nunca"
            ranking_text.append(
                f"{medal}**{idx+1}.** {username} - {stats['count']} anota√ß√µes\n"
                f"√öltima: {last_recorded}"
            )
        
        embed.description = "\n\n".join(ranking_text)
        return embed

    def create_boss_embed(compact=False):
        """Cria embed com a tabela de timers de boss"""
        now = datetime.now(brazil_tz)
        
        embed = discord.Embed(
            title=f"BOSS TIMER - {now.strftime('%d/%m/%Y %H:%M:%S')} BRT",
            color=discord.Color.gold()
        )
        
        for boss in boss_timers:
            boss_info = []
            for sala in boss_timers[boss]:
                timers = boss_timers[boss][sala]
                
                # Pular bosses que j√° fecharam e n√£o foram registrados
                if timers['closed_time'] and now >= timers['closed_time'] and timers['death_time'] is None:
                    continue
                    
                if compact and timers['death_time'] is None:
                    continue
                    
                death_time = timers['death_time'].strftime("%d/%m %H:%M") if timers['death_time'] else "--/-- --:--"
                respawn_time = timers['respawn_time'].strftime("%H:%M") if timers['respawn_time'] else "--:--"
                closed_time = timers['closed_time'].strftime("%H:%M") if timers['closed_time'] else "--:--"
                recorded_by = f" ({timers['recorded_by']})" if timers['recorded_by'] else ""
                
                status = ""
                if timers['respawn_time']:
                    if now >= timers['respawn_time']:
                        if timers['closed_time'] and now >= timers['closed_time']:
                            status = "‚ùå"  # Boss fechado
                        else:
                            status = "‚úÖ"  # Boss aberto
                    else:
                        time_left = format_time_remaining(timers['respawn_time'])
                        status = f"üïí ({time_left})"  # Boss agendado
                else:
                    status = "‚ùå"  # Sem registro
                
                boss_info.append(
                    f"Sala {sala}: {death_time} [de {respawn_time} at√© {closed_time}] {status}{recorded_by}"
                )
            
            if not boss_info and compact:
                continue
                
            if boss_info:
                embed.add_field(
                    name=f"**{boss}**",
                    value="\n".join(boss_info) if boss_info else "Nenhum hor√°rio registrado",
                    inline=False
                )
        
        return embed

    async def create_next_bosses_embed(boss_timers):
        """Cria embed com os pr√≥ximos bosses a abrir"""
        next_bosses = get_next_bosses(boss_timers)
        
        embed = discord.Embed(
            title="‚è≥ PR√ìXIMOS BOSSES E BOSSES ABERTOS",
            color=discord.Color.blue()
        )
        
        if not next_bosses:
            embed.description = "Nenhum boss programado para abrir em breve ou atualmente aberto."
            return embed
        
        boss_info = []
        for boss in next_bosses:
            recorded_by = f" (Anotado por: {boss['recorded_by']})" if boss['recorded_by'] else ""
            
            if boss['status'] == 'open':
                boss_info.append(
                    f"üü¢ **{boss['boss']} (Sala {boss['sala']})** - ABERTO AGORA!\n"
                    f"‚è≥ Fecha em: {boss['time_left']} ({boss['closed_time'].strftime('%d/%m %H:%M')} BRT){recorded_by}"
                )
            else:
                boss_info.append(
                    f"üü° **{boss['boss']} (Sala {boss['sala']})** - ABRE EM {boss['time_left']}\n"
                    f"‚è∞ Hor√°rio: {boss['respawn_time'].strftime('%d/%m %H:%M')} BRT{recorded_by}"
                )
        
        embed.description = "\n\n".join(boss_info)
        return embed

    async def update_table(channel):
        """Atualiza a mensagem da tabela de bosses"""
        nonlocal table_message
        
        try:
            embed = create_boss_embed()
            view = BossControlView(
                bot, 
                boss_timers, 
                user_stats, 
                user_notifications, 
                table_message, 
                NOTIFICATION_CHANNEL_ID,
                update_table,
                create_next_bosses_embed,
                create_ranking_embed,
                lambda: create_history_embed(bot, boss_timers),
                lambda: create_unrecorded_embed(bot, boss_timers)
            )
            
            if table_message:
                try:
                    await asyncio.sleep(1)  # Delay para evitar rate limit
                    await table_message.edit(embed=embed, view=view)
                    return
                except discord.NotFound:
                    table_message = None
                except discord.HTTPException as e:
                    if e.status == 429:
                        retry_after = e.retry_after
                        print(f"Rate limit ao editar tabela. Tentando novamente em {retry_after} segundos")
                        await asyncio.sleep(retry_after)
                        return await update_table(channel)
                    else:
                        print(f"Erro HTTP ao editar mensagem da tabela: {e}")
                        table_message = None
                except Exception as e:
                    print(f"Erro ao editar mensagem da tabela: {e}")
                    table_message = None
            
            if not table_message:
                async for message in channel.history(limit=50):
                    if message.author == bot.user and message.embeds and "BOSS TIMER" in message.embeds[0].title:
                        try:
                            await asyncio.sleep(1)  # Delay para evitar rate limit
                            await message.edit(embed=embed, view=view)
                            table_message = message
                            return
                        except:
                            continue
            
            await asyncio.sleep(1)  # Delay para evitar rate limit
            table_message = await channel.send(embed=embed, view=view)
        except discord.HTTPException as e:
            if e.status == 429:
                retry_after = e.retry_after
                print(f"Rate limit ao enviar tabela. Tentando novamente em {retry_after} segundos")
                await asyncio.sleep(retry_after)
                return await update_table(channel)
            else:
                print(f"Erro HTTP ao atualizar tabela: {e}")
        except Exception as e:
            print(f"Erro ao atualizar tabela: {e}")
            try:
                await asyncio.sleep(1)  # Delay para evitar rate limit
                table_message = await channel.send(embed=create_boss_embed(), view=BossControlView(
                    bot, 
                    boss_timers, 
                    user_stats, 
                    user_notifications, 
                    table_message, 
                    NOTIFICATION_CHANNEL_ID,
                    update_table,
                    create_next_bosses_embed,
                    create_ranking_embed,
                    lambda: create_history_embed(bot, boss_timers),
                    lambda: create_unrecorded_embed(bot, boss_timers)
                ))
            except Exception as e:
                print(f"Erro ao enviar nova mensagem de tabela: {e}")

    # Tasks
    @tasks.loop(seconds=60)  # Alterado de 30 para 60 segundos para reduzir rate limits
    async def live_table_updater():
        """Atualiza a tabela periodicamente"""
        try:
            channel = bot.get_channel(NOTIFICATION_CHANNEL_ID)
            if channel:
                await update_table(channel)
        except Exception as e:
            print(f"Erro na task de atualiza√ß√£o de tabela: {e}")

    @tasks.loop(minutes=1)
    async def check_boss_respawns():
        """Verifica os respawns de boss e envia notifica√ß√µes"""
        try:
            channel = bot.get_channel(NOTIFICATION_CHANNEL_ID)
            if channel is None:
                print(f"Erro: Canal com ID {NOTIFICATION_CHANNEL_ID} n√£o encontrado!")
                return

            now = datetime.now(brazil_tz)
            notifications = []
            dm_notifications = []

            for boss in boss_timers:
                for sala in boss_timers[boss]:
                    timers = boss_timers[boss][sala]
                    respawn_time = timers['respawn_time']
                    closed_time = timers['closed_time']
                    
                    if respawn_time is not None:
                        # Notifica√ß√£o de pr√©-abertura (5 minutos antes)
                        if now >= (respawn_time - timedelta(minutes=5)) and now < respawn_time:
                            time_left = format_time_remaining(respawn_time)
                            recorded_by = f"\nAnotado por: {timers['recorded_by']}" if timers['recorded_by'] else ""
                            notifications.append(f"üü° **{boss} (Sala {sala})** estar√° dispon√≠vel em {time_left} ({respawn_time:%d/%m %H:%M} BRT){recorded_by}")
                        
                        # Notifica√ß√£o de abertura
                        if now >= respawn_time and closed_time is not None and now < closed_time:
                            if not timers.get('opened_notified', False):
                                recorded_by = f"\nAnotado por: {timers['recorded_by']}" if timers['recorded_by'] else ""
                                notifications.append(f"üü¢ **{boss} (Sala {sala})** est√° dispon√≠vel AGORA! (aberto at√© {closed_time:%d/%m %H:%M} BRT){recorded_by}")
                                boss_timers[boss][sala]['opened_notified'] = True
                                await save_timer(boss, sala, timers['death_time'], respawn_time, closed_time, timers['recorded_by'], True)
                                
                                for user_id in user_notifications:
                                    if boss in user_notifications[user_id]:
                                        dm_notifications.append({
                                            'user_id': user_id,
                                            'boss_name': boss,
                                            'sala': sala,
                                            'respawn_time': respawn_time,
                                            'closed_time': closed_time
                                        })
                        
                        # Notifica√ß√£o de fechamento
                        if closed_time is not None and abs((now - closed_time).total_seconds()) < 60:
                            message = f"üî¥ **{boss} (Sala {sala})** FECHOU"
                            if not timers.get('opened_notified', False):
                                message += " sem nenhuma anota√ß√£o durante o per√≠odo aberto!"
                            else:
                                message += "!"

                            notifications.append(message)
                            
                            # Apenas marca que foi fechado, sem apagar os hor√°rios
                            boss_timers[boss][sala]['opened_notified'] = False

                            # Atualiza no banco com os mesmos dados (para manter integridade)
                            await save_timer(
                                boss,
                                sala,
                                timers['death_time'],
                                timers['respawn_time'],
                                timers['closed_time'],
                                timers['recorded_by'],
                                False
                            )

            if notifications:
                message = "**Notifica√ß√µes de Boss:**\n" + "\n".join(notifications)
                try:
                    await asyncio.sleep(1)  # Delay para evitar rate limit
                    await channel.send(message)
                except discord.HTTPException as e:
                    if e.status == 429:
                        retry_after = e.retry_after
                        print(f"Rate limit nas notifica√ß√µes. Tentando novamente em {retry_after} segundos")
                        await asyncio.sleep(retry_after)
                        await channel.send(message[:2000])  # Envia mensagem truncada se necess√°rio
                    else:
                        print(f"Erro HTTP ao enviar notifica√ß√µes: {e}")
            
            if dm_notifications:
                for notification in dm_notifications:
                    await send_notification_dm(
                        bot,
                        notification['user_id'],
                        notification['boss_name'],
                        notification['sala'],
                        notification['respawn_time'],
                        notification['closed_time']
                    )
                    await asyncio.sleep(1)  # Delay entre notifica√ß√µes DM
            
            await asyncio.sleep(1)  # Delay antes de atualizar a tabela
            await update_table(channel)
        
        except discord.HTTPException as e:
            if e.status == 429:
                retry_after = e.retry_after
                print(f"Rate limit na verifica√ß√£o de respawns. Tentando novamente em {retry_after} segundos")
                await asyncio.sleep(retry_after)
            else:
                print(f"Erro HTTP na verifica√ß√£o de respawns: {e}")
        except Exception as e:
            print(f"Erro na verifica√ß√£o de respawns: {e}")

    @tasks.loop(minutes=30)
    async def periodic_table_update():
        """Atualiza a tabela periodicamente com novo post"""
        try:
            channel = bot.get_channel(NOTIFICATION_CHANNEL_ID)
            if channel:
                # Enviar nova mensagem com a tabela atualizada
                embed = create_boss_embed()
                view = BossControlView(
                    bot, 
                    boss_timers, 
                    user_stats, 
                    user_notifications, 
                    table_message, 
                    NOTIFICATION_CHANNEL_ID,
                    update_table,
                    create_next_bosses_embed,
                    create_ranking_embed,
                    lambda: create_history_embed(bot, boss_timers),
                    lambda: create_unrecorded_embed(bot, boss_timers)
                )
                await asyncio.sleep(1)  # Delay para evitar rate limit
                await channel.send(embed=embed, view=view)
            
            # Ajustar o intervalo para um valor aleat√≥rio entre 30 e 60 minutos
            periodic_table_update.change_interval(minutes=random.randint(30, 60))
        
        except discord.HTTPException as e:
            if e.status == 429:
                retry_after = e.retry_after
                print(f"Rate limit na atualiza√ß√£o peri√≥dica. Tentando novamente em {retry_after} segundos")
                await asyncio.sleep(retry_after)
            else:
                print(f"Erro HTTP na atualiza√ß√£o peri√≥dica: {e}")
        except Exception as e:
            print(f"Erro na atualiza√ß√£o peri√≥dica: {e}")

    # Comandos Slash
    async def boss_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:
        bosses = list(boss_timers.keys())
        return [
            app_commands.Choice(name=boss, value=boss)
            for boss in bosses if current.lower() in boss.lower()
        ][:25]

    async def sala_autocomplete(interaction: discord.Interaction, current: str) -> list[app_commands.Choice[int]]:
        salas = list(boss_timers[list(boss_timers.keys())[0]].keys())
        return [
            app_commands.Choice(name=f"Sala {sala}", value=sala)
            for sala in salas if current in str(sala)
        ][:25]

    @bot.tree.command(name="boss", description="Registra a morte de um boss")
    @app_commands.autocomplete(boss_name=boss_autocomplete, sala=sala_autocomplete)
    @app_commands.describe(
        boss_name="Nome do boss",
        sala="N√∫mero da sala (1-8)",
        hora_morte="Hor√°rio da morte (formato HH:MM ou HHhMM)",
        foi_ontem="Se a morte foi ontem (padr√£o: n√£o)"
    )
    async def boss_slash(
        interaction: discord.Interaction,
        boss_name: str,
        sala: int,
        hora_morte: str,
        foi_ontem: bool = False
    ):
        """Registra a morte de um boss via comando slash"""
        try:
            if interaction.channel.id != NOTIFICATION_CHANNEL_ID:
                await interaction.response.send_message(
                    "‚ö† Comandos s√≥ s√£o aceitos no canal designado!",
                    ephemeral=True
                )
                return
            
            full_boss_name = get_boss_by_abbreviation(boss_name, boss_timers)
            if full_boss_name is None:
                await interaction.response.send_message(
                    f"Boss inv√°lido. Bosses dispon√≠veis: {', '.join(boss_timers.keys())}",
                    ephemeral=True
                )
                return
            
            boss_name = full_boss_name
            
            if sala not in boss_timers[boss_name]:
                await interaction.response.send_message(
                    f"Sala inv√°lida. Salas dispon√≠veis: {', '.join(map(str, boss_timers[boss_name].keys()))}",
                    ephemeral=True
                )
                return
            
            time_parts = parse_time_input(hora_morte)
            if not time_parts:
                await interaction.response.send_message(
                    "Formato de hora inv√°lido. Use HH:MM ou HHhMM (ex: 14:30 ou 14h30)",
                    ephemeral=True
                )
                return
            
            hour, minute = time_parts
            
            if not validate_time(hour, minute):
                await interaction.response.send_message(
                    "Hor√°rio inv√°lido. Hora deve estar entre 00-23 e minutos entre 00-59.",
                    ephemeral=True
                )
                return
            
            now = datetime.now(brazil_tz)
            death_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
            
            if foi_ontem or death_time > now:
                death_time -= timedelta(days=1)
            
            respawn_time = death_time + timedelta(hours=8)
            recorded_by = interaction.user.name
            
            boss_timers[boss_name][sala] = {
                'death_time': death_time,
                'respawn_time': respawn_time,
                'closed_time': respawn_time + timedelta(hours=4),
                'recorded_by': recorded_by,
                'opened_notified': False
            }
            
            user_id = str(interaction.user.id)
            if user_id not in user_stats:
                user_stats[user_id] = {'count': 0, 'last_recorded': None}
            user_stats[user_id]['count'] += 1
            user_stats[user_id]['last_recorded'] = now
            
            await save_timer(boss_name, sala, death_time, respawn_time, respawn_time + timedelta(hours=4), recorded_by)
            await save_user_stats(user_id, interaction.user.name, user_stats[user_id]['count'], now)
            
            await interaction.response.send_message(
                f"‚úÖ **{boss_name} (Sala {sala})** registrado por {recorded_by}:\n"
                f"- Morte: {death_time.strftime('%d/%m %H:%M')} BRT\n"
                f"- Abre: {respawn_time.strftime('%d/%m %H:%M')} BRT\n"
                f"- Fecha: {(respawn_time + timedelta(hours=4)).strftime('%d/%m %H:%M')} BRT",
                ephemeral=False
            )
            
            # Atualiza a tabela
            embed = create_boss_embed(boss_timers)
            view = BossControlView(
                bot,
                boss_timers,
                user_stats,
                user_notifications,
                table_message,
                NOTIFICATION_CHANNEL_ID,
                update_table,
                create_next_bosses_embed,
                create_ranking_embed,
                lambda: create_history_embed(bot, boss_timers),
                lambda: create_unrecorded_embed(bot, boss_timers)
            )
            await interaction.followup.send(embed=embed, view=view)
            
        except Exception as e:
            print(f"Erro no comando slash boss: {e}")
            traceback.print_exc()
            await interaction.response.send_message(
                "Ocorreu um erro ao processar seu comando.",
                ephemeral=True
            )

    @bot.tree.command(name="clearboss", description="Limpa o timer de um boss")
    @app_commands.autocomplete(boss_name=boss_autocomplete)
    @app_commands.describe(
        boss_name="Nome do boss",
        sala="N√∫mero da sala (opcional, deixe em branco para limpar todas)"
    )
    async def clearboss_slash(
        interaction: discord.Interaction,
        boss_name: str,
        sala: Optional[int] = None
    ):
        """Limpa o timer de um boss via comando slash"""
        try:
            if interaction.channel.id != NOTIFICATION_CHANNEL_ID:
                await interaction.response.send_message(
                    "‚ö† Comandos s√≥ s√£o aceitos no canal designado!",
                    ephemeral=True
                )
                return
            
            full_boss_name = get_boss_by_abbreviation(boss_name, boss_timers)
            if full_boss_name is None:
                await interaction.response.send_message(
                    f"Boss inv√°lido. Bosses dispon√≠veis: {', '.join(boss_timers.keys())}",
                    ephemeral=True
                )
                return
            
            boss_name = full_boss_name
            
            if sala is None:
                for s in boss_timers[boss_name]:
                    boss_timers[boss_name][s] = {
                        'death_time': None,
                        'respawn_time': None,
                        'closed_time': None,
                        'recorded_by': None,
                        'opened_notified': False
                    }
                await clear_timer(boss_name)
                await interaction.response.send_message(
                    f"‚úÖ Todos os timers do boss **{boss_name}** foram resetados.",
                    ephemeral=True
                )
            else:
                if sala not in boss_timers[boss_name]:
                    await interaction.response.send_message(
                        f"Sala inv√°lida. Salas dispon√≠veis: {', '.join(map(str, boss_timers[boss_name].keys()))}",
                        ephemeral=True
                    )
                    return
                
                boss_timers[boss_name][sala] = {
                    'death_time': None,
                    'respawn_time': None,
                    'closed_time': None,
                    'recorded_by': None,
                    'opened_notified': False
                }
                await clear_timer(boss_name, sala)
                await interaction.response.send_message(
                    f"‚úÖ Timer do boss **{boss_name} (Sala {sala})** foi resetado.",
                    ephemeral=True
                )
            
            # Atualiza a tabela
            embed = create_boss_embed(boss_timers)
            view = BossControlView(
                bot,
                boss_timers,
                user_stats,
                user_notifications,
                table_message,
                NOTIFICATION_CHANNEL_ID,
                update_table,
                create_next_bosses_embed,
                create_ranking_embed,
                lambda: create_history_embed(bot, boss_timers),
                lambda: create_unrecorded_embed(bot, boss_timers)
            )
            await interaction.followup.send(embed=embed, view=view)
            
        except Exception as e:
            print(f"Erro no comando slash clearboss: {e}")
            traceback.print_exc()
            await interaction.response.send_message(
                "Ocorreu um erro ao processar seu comando.",
                ephemeral=True
            )

    @bot.tree.command(name="nextboss", description="Mostra os pr√≥ximos bosses a abrir")
    async def nextboss_slash(interaction: discord.Interaction):
        """Mostra os pr√≥ximos bosses via comando slash"""
        try:
            if interaction.channel.id != NOTIFICATION_CHANNEL_ID:
                await interaction.response.send_message(
                    "‚ö† Comandos s√≥ s√£o aceitos no canal designado!",
                    ephemeral=True
                )
                return
            
            await interaction.response.defer()
            embed = await create_next_bosses_embed(boss_timers)
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            print(f"Erro no comando slash nextboss: {e}")
            traceback.print_exc()
            await interaction.response.send_message(
                "Ocorreu um erro ao buscar os pr√≥ximos bosses.",
                ephemeral=True
            )

    @bot.tree.command(name="setupboss", description="Recria a tabela de bosses com bot√µes de controle")
    async def setup_boss_slash(interaction: discord.Interaction):
        """Recria a tabela de bosses via comando slash"""
        try:
            if interaction.channel.id != NOTIFICATION_CHANNEL_ID:
                await interaction.response.send_message(
                    "‚ö† Comandos s√≥ s√£o aceitos no canal designado!",
                    ephemeral=True
                )
                return
                
            embed = create_boss_embed()
            view = BossControlView(
                bot, 
                boss_timers, 
                user_stats, 
                user_notifications, 
                table_message, 
                NOTIFICATION_CHANNEL_ID,
                update_table,
                create_next_bosses_embed,
                create_ranking_embed,
                lambda: create_history_embed(bot, boss_timers),
                lambda: create_unrecorded_embed(bot, boss_timers)
            )
            await interaction.response.send_message(embed=embed, view=view)
        
        except Exception as e:
            print(f"Erro no comando slash setupboss: {e}")
            traceback.print_exc()
            await interaction.response.send_message(
                "Ocorreu um erro ao recriar a tabela.",
                ephemeral=True
            )

    # Iniciar as tasks
    check_boss_respawns.start()
    live_table_updater.start()
    periodic_table_update.start()

    # Retornar as fun√ß√µes necess√°rias para o utility_commands.py
    return (
        create_boss_embed,
        update_table,
        create_next_bosses_embed,
        create_ranking_embed,
        lambda: create_history_embed(bot, boss_timers),
        lambda: create_unrecorded_embed(bot, boss_timers)
    )